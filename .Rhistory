width_test <- function(ymin, ymax, model) {
a <- rbinom(n, 1, 0.5)
x <- as.data.frame(matrix(rnorm(2*n), ncol = 2, nrow = n))
y <- runif(n, ymin, ymax)
max_width <- ymax - ymin
res <- get_bound(y = y, a = a, x = x, ymin = ymin, ymax = ymax,
outfam = gaussian(),  treatfam = binomial(),
model = model, eps = c(0, 1), delta = c(0, 1),
do_mult_boot = FALSE, do_eps_zero = FALSE, nsplits = 1,
alpha = 0.05, B = NULL, sl.lib = "SL.glm",
do_parallel = FALSE, ncluster = NULL)$bounds
max_widthc <- as.character(max_width)
expect_equal(res["0", "lb" , "0"] - res["0", "ub" , "0"], 0)
expect_equal(res["1", "lb" , "0"] - res["1", "ub" , "0"], 0)
expect_equal(res["0", "lb" , "1"] - res["0", "ub" , "1"], 0)
expect_equal(res["1", "ub" , "1"] - res["1", "lb" , "1"], max_width)
}
width_test_wrapper <- function() {
width_test(0, 1, "x")
width_test(0, 1, "xa")
ymin <- runif(1, -100, 100)
ymax <- ymin + runif(1, 0, 200)
width_test(ymin, ymax, "x")
width_test(ymin, ymax, "xa")
}
pbreplicate(nsim, width_test_wrapper())
width_test <- function(ymin, ymax, model) {
a <- rbinom(n, 1, 0.5)
x <- as.data.frame(matrix(rnorm(2*n), ncol = 2, nrow = n))
y <- runif(n, ymin, ymax)
max_width <- ymax - ymin
res <- get_bound(y = y, a = a, x = x, ymin = ymin, ymax = ymax,
outfam = gaussian(),  treatfam = binomial(),
model = model, eps = c(0, 1), delta = c(0, 1),
do_mult_boot = FALSE, do_eps_zero = FALSE, nsplits = 2,
alpha = 0.05, B = NULL, sl.lib = "SL.glm",
do_parallel = FALSE, ncluster = NULL)$bounds
max_widthc <- as.character(max_width)
expect_equal(res["0", "lb" , "0"] - res["0", "ub" , "0"], 0)
expect_equal(res["1", "lb" , "0"] - res["1", "ub" , "0"], 0)
expect_equal(res["0", "lb" , "1"] - res["0", "ub" , "1"], 0)
expect_equal(res["1", "ub" , "1"] - res["1", "lb" , "1"], max_width)
}
width_test_wrapper <- function() {
width_test(0, 1, "x")
width_test(0, 1, "xa")
ymin <- runif(1, -100, 100)
ymax <- ymin + runif(1, 0, 200)
width_test(ymin, ymax, "x")
width_test(ymin, ymax, "xa")
}
pbreplicate(nsim, width_test_wrapper())
library("devtools")
library(roxygen2)
setwd("C:/Users/matte/Desktop/sensitivitypuc")
document()
# devtools::use_testthat()
# Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS=TRUE)
# devtools::install_github("matteobonvini/sensitivitypuc")
devtools::install("C:/Users/matte/Desktop/sensitivitypuc")
library(sensitivitypuc)
nsim  <- 500
n <- 500
width_test <- function(ymin, ymax, model) {
a <- rbinom(n, 1, 0.5)
x <- as.data.frame(matrix(rnorm(2*n), ncol = 2, nrow = n))
y <- runif(n, ymin, ymax)
max_width <- ymax - ymin
res <- get_bound(y = y, a = a, x = x, ymin = ymin, ymax = ymax,
outfam = gaussian(),  treatfam = binomial(),
model = model, eps = c(0, 1), delta = c(0, 1),
do_mult_boot = FALSE, do_eps_zero = FALSE, nsplits = 1,
alpha = 0.05, B = NULL, sl.lib = "SL.glm",
do_parallel = FALSE, ncluster = NULL)$bounds
max_widthc <- as.character(max_width)
expect_equal(res["0", "lb" , "0"] - res["0", "ub" , "0"], 0)
expect_equal(res["1", "lb" , "0"] - res["1", "ub" , "0"], 0)
expect_equal(res["0", "lb" , "1"] - res["0", "ub" , "1"], 0)
expect_equal(res["1", "ub" , "1"] - res["1", "lb" , "1"], max_width)
}
width_test_wrapper <- function() {
width_test(0, 1, "x")
width_test(0, 1, "xa")
ymin <- runif(1, -100, 100)
ymax <- ymin + runif(1, 0, 200)
width_test(ymin, ymax, "x")
width_test(ymin, ymax, "xa")
}
pbreplicate(nsim, width_test_wrapper())
nsim  <- 500
n <- 500
width_test <- function(ymin, ymax, model) {
a <- rbinom(n, 1, 0.5)
x <- as.data.frame(matrix(rnorm(2*n), ncol = 2, nrow = n))
y <- runif(n, ymin, ymax)
max_width <- ymax - ymin
res <- get_bound(y = y, a = a, x = x, ymin = ymin, ymax = ymax,
outfam = gaussian(),  treatfam = binomial(),
model = model, eps = c(0, 1), delta = c(0, 1),
do_mult_boot = FALSE, do_eps_zero = FALSE, nsplits = 1,
alpha = 0.05, B = NULL, sl.lib = "SL.glm",
do_parallel = TRUE, ncluster = 2)$bounds
max_widthc <- as.character(max_width)
expect_equal(res["0", "lb" , "0"] - res["0", "ub" , "0"], 0)
expect_equal(res["1", "lb" , "0"] - res["1", "ub" , "0"], 0)
expect_equal(res["0", "lb" , "1"] - res["0", "ub" , "1"], 0)
expect_equal(res["1", "ub" , "1"] - res["1", "lb" , "1"], max_width)
}
width_test_wrapper <- function() {
width_test(0, 1, "x")
width_test(0, 1, "xa")
ymin <- runif(1, -100, 100)
ymax <- ymin + runif(1, 0, 200)
width_test(ymin, ymax, "x")
width_test(ymin, ymax, "xa")
}
pbreplicate(nsim, width_test_wrapper())
library("devtools")
library(roxygen2)
setwd("C:/Users/matte/Desktop/sensitivitypuc")
document()
# devtools::use_testthat()
# Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS=TRUE)
# devtools::install_github("matteobonvini/sensitivitypuc")
devtools::install("C:/Users/matte/Desktop/sensitivitypuc")
library(sensitivitypuc)
devtools::test()
##########################################################
## Analyze data of Connors et al (1996) as in Section 5 ##
##########################################################
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(devtools)
library(varhandle)
Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS = TRUE)
devtools::install_github("matteobonvini/sensitivitypuc")
library(sensitivitypuc)
set.seed(1000)
data_url <- "http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/rhc.csv"
dat <- read.csv(data_url, header = TRUE)
covariates <- c("age", "sex", "race", "edu", "income",
"ninsclas", "cat1", "cat2",
"resp", "card", "neuro", "gastr", "renal", "meta",
"hema", "seps", "trauma", "ortho",
"adld3p", "das2d3pc", "dnr1", "ca",  "aps1", "scoma1",
"wtkilo1", "temp1", "meanbp1", "resp1", "hrt1", "pafi1",
"paco21", "ph1", "wblc1", "hema1", "sod1", "pot1", "crea1",
"bili1", "alb1", "urin1",
"cardiohx", "chfhx", "dementhx",
"psychhx", "chrpulhx", "renalhx", "liverhx", "gibledhx",
"malighx", "immunhx", "transhx", "amihx")
# Exclude covariates with missing values
x <- dat[, covariates]
miss_covs <- covariates[apply(x, 2, function(x) sum(is.na(x)) > 0)]
print(paste("Discarding covariates:", paste(miss_covs, collapse = ", ")))
x <- x[, !covariates %in% miss_covs]
# Fix factors or otherwise SuperLearner complains
newdf <- x
for(i in 1:ncol(x)) {
if(class(x[, i])=="factor") {
new <- to.dummy(x[, i], colnames(x)[i])
newdf <- newdf[, !colnames(newdf)%in%colnames(x)[i]]
newdf <- cbind(newdf, new[, -1, drop=FALSE])
}
}
x <- newdf
rm(newdf)
rm(new)
# Avoid SuperLearner conflicts due to variable names
colnames(x) <- paste("x", 1:ncol(x), sep = "")
# A = 1 means patient underwent RHC
a <- ifelse(dat$swang1 == "No RHC", 0, 1)
# Y = 1 means survival at day 30
y <- ifelse(dat$dth30 == "No", 1, 0)
# Select values for prop of unmeasured confounding at which evaluate bounds
eps_seq <- seq(0, 0.6, 0.0001)
delta_seq <- c(0.25, 0.50, 0.75, 1)
# Select model, "x" = S \ind (Y, A) | X, "xa" = S \ind Y | (X, A)
model <- c("x", "xa")
# Select SuperLearner Library
sl.lib <- c("SL.mean", "SL.speedlm", "SL.speedglm", "SL.gam",
"SL.ranger", "SL.polymars", "SL.svm")
# Estimate Regression functions once for both model "x" and model "xa"
# There is a "non-list contrasts argument ignored" warning from SL gam library
# coming from model.matrix, which I think can be ignored.
nuis_fns <- do_crossfit(y = y, a = a, x = x, ymin = 0, ymax = 1, nsplits = 5,
outfam = binomial(), treatfam = binomial(),
sl.lib = sl.lib, do_parallel = TRUE, ncluster = 3,
show_progress = FALSE)
saveRDS(nuis_fns, file = "./results/data analysis/nuis_fns_rhc.RData")
nuis_fns <- readRDS("./results/data analysis/nuis_fns_rhc.RData")
res_x <- get_bound(y = y, a = a, x = x, ymin = 0, ymax = 1, model = "x",
eps = eps_seq, delta = delta_seq, nuis_fns = nuis_fns,
alpha = 0.05, B = 10000, do_mult_boot = TRUE,
do_parallel = FALSE, do_eps_zero = TRUE, do_rearrange = TRUE)
res_xa <- get_bound(y = y, a = a, x = x, ymin = 0, ymax = 1, model = "xa",
eps = eps_seq, delta = delta_seq, nuis_fns = nuis_fns,
alpha = 0.05, B = 10000, do_mult_boot = TRUE,
do_parallel = FALSE, do_eps_zero = TRUE,
do_rearrange = TRUE)
bound_x <- res_x$bounds
bound_xa <- res_xa$bounds
eps_zero_x <- res_x$eps_zero
eps_zero_xa <- res_xa$eps_zero
# Export result in a user-friendly format
out <- NULL
for(i in 1:length(delta_seq)) {
# Loop through the values of deltas and append
dd <- delta_seq[i]
bound_x <- cbind(eps_seq, dd, res_x$bounds[, , as.character(dd)],
eps_zero_x$est[i], eps_zero_x$ci_lo[i], eps_zero_x$ci_hi[i],
"x")
bound_xa <- cbind(eps_seq, dd, res_xa$bounds[, , as.character(dd)],
eps_zero_xa$est[i], eps_zero_xa$ci_lo[i],
eps_zero_xa$ci_hi[i], "xa")
bound <- rbind(bound_x, bound_xa)
out <- rbind(out, bound)
}
colnames(out) <- c("epsilon", "delta", colnames(res_x$bounds[, , 1]),
"eps_zero", "eps_zero_lo", "eps_zero_hi", "model")
write.csv(out, "./results/data analysis/rhc_bounds.csv", row.names = FALSE)
##################################################################
## Generate plot of the bounds for data of Connors et al (1996) ##
##################################################################
rm(list = ls())
library(RColorBrewer)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("plot_theme.R")
dat <- read.csv("./results/data analysis/rhc_bounds.csv")
datx <- dat[dat$model == "x" & dat$delta == 1 & dat$epsilon <= 0.5, ]
datxa <- dat[dat$model == "xa" & dat$delta == 1 & dat$epsilon <= 0.5, ]
ylims <- c(-0.45, 0.32)
models <- c("x", "xa")
colors_x <- brewer.pal(4, "YlOrRd")
colors_xa <- brewer.pal(4, "Blues")
eps0_label_fn <- function(dat, delta) {
# Return value for estimate of eps0 for a given delta, dat must be data.frame
# that results from get_bound() function.
out <- round(dat[dat$delta == delta, ]$eps_zero[1], 2)
return(out)
}
unconfound_val <- round(dat$lb[dat$epsilon == 0][1], 3)
unconfound_label <- as.character(unconfound_val * 100)
eps0_xa_label <- as.character(eps0_label_fn(datxa, 1) * 100)
eps0_x_label <- as.character(eps0_label_fn(datx, 1) * 100)
for(mm in models) {
## Generate plots for Figure 1, eps in [0, 0.5], delta = 1.
dat_mm <- dat[dat$model == mm & dat$delta == 1 & dat$epsilon <= 0.5, ]
xaxis_breaks <- c(0, dat_mm$eps_zero[1], 0.20, 0.30, 0.50)
ytitle <- ifelse(mm == "x", "Difference in survival (%)", "")
if(mm == "x") {
colors <- colors_x
eps0_label <- eps0_x_label
}
if(mm == "xa") {
colors <- colors_xa
eps0_label <- eps0_xa_label
}
xaxis_labs <- c(0, eps0_label, 20, 30, 50)
p <- ggplot() +
geom_ribbon(data = dat_mm, aes(x = epsilon, ymin = ci_lb_lo_unif,
ymax = ci_ub_hi_unif),
fill = colors[4], alpha = 1) +
geom_ribbon(data = dat_mm, aes(x = epsilon, ymin = ci_im04_lo,
ymax = ci_im04_hi), fill = colors[2],
alpha = 1) +
geom_ribbon(data = dat_mm, aes(x = epsilon, ymin = lb, ymax = ub),
fill = colors[1], alpha = 1) +
geom_line(data = dat_mm, aes(x = epsilon, y = lb), color = "black",
size = 1.1) +
geom_line(data = dat_mm, aes(x = epsilon, y = ub), color = "black",
size = 1.1) +
geom_segment(data = dat_mm[1, ], size = 0.8, colour = "black", alpha = 0.5,
aes(x = eps_zero, xend = eps_zero, y = ylims[1],  yend = 0)) +
geom_segment(data = dat_mm[1, ], size = 0.8, colour = "black", alpha = 0.5,
aes(x = 0, xend = eps_zero, y = 0, yend = 0)) +
scale_x_continuous(breaks = xaxis_breaks,
expand = c(0, 0), limits = c(0, 0.502),
labels = xaxis_labs) +
scale_y_continuous(breaks = c(-0.4, -0.2, unconfound_val, 0, 0.2),
expand = c(0,0), limits = ylims,
labels = c(-40, -20, unconfound_label, 0, 20)) +
scale_colour_manual(name = "model", values = colors) +
scale_fill_manual(name = "model", values = colors) +
labs(x = "% of Confounded Units", y = ytitle, colour = "", fill = "") +
our_theme +
theme(legend.position = "none")
ggsave(filename = paste0("./results/data analysis/rhc_bounds_epsilon_", mm,
".pdf"), p, height = 3, width = 3)
}
## Superimposing the two plots
p2 <- ggplot() +
geom_ribbon(data = datxa,
aes(x = epsilon, ymin = lb, ymax = ub), fill = colors_xa[2],
alpha = 1) +
geom_ribbon(data = datx,
aes(x = epsilon, ymin = lb, ymax = ub), fill = colors_x[2],
alpha = 1) +
geom_line(data = datx, aes(x = epsilon, y = lb), color = "black",
size = 1.1) +
geom_line(data = datxa, aes(x = epsilon, y = lb), color = "black",
linetype = "dashed", size = 1.1) +
geom_line(data = datx, aes(x = epsilon, y = ub), color = "black",
size = 1.1) +
geom_line(data = datxa, aes(x = epsilon, y = ub), color = "black",
linetype = "dashed", size = 1.1) +
geom_segment(data = datx[1, ],
aes(x = eps_zero, xend = eps_zero, y = ylims[1], yend = 0),
size = 0.8, colour = "red", alpha = 0.75) +
geom_segment(data = datxa[1, ],
aes(x = eps_zero, xend = eps_zero, y = ylims[1], yend = 0),
size = 0.8, colour = "blue", alpha = 0.75) +
geom_segment(data = datx[1, ],
aes(x = 0, xend = eps_zero, y = 0, yend = 0),
size = 0.8, colour = "black", alpha = 0.5) +
scale_x_continuous(breaks = c(0, datxa$eps_zero[1],
datx$eps_zero[1], 0.2,0.5),
expand = c(0, 0), limits = c(0, 0.5),
labels = c(0, eps0_xa_label, eps0_x_label, 20, 50)) +
scale_y_continuous(breaks = c(-0.2, -0.1, unconfound_val, 0, 0.1),
expand = c(0,0), limits = ylims,
labels = c("-20", "-10", unconfound_label, "0", "10")) +
scale_colour_manual(name = "model", values = colors) +
scale_fill_manual(name = "model", values = colors) +
labs(x = "% of Confounded Units", y = "Difference in survival (%)",
colour = "", fill = "") +
our_theme +
theme(legend.position = "none")
ggsave(filename = "./results/data analysis/rhc_bounds_epsilon.pdf", p2,
height = 3, width = 3)
## Plot eps_delta
dat <- read.csv("./results/data analysis/rhc_bounds.csv")
models <- c("x", "xa")
ylims <- c(-0.45, 0.32)
for(mm in models) {
## Generate plots for appendix figure, eps in [0, 0.5] with different deltas.
dat_mm <- dat[dat$model == mm & dat$epsilon <= 0.5, ]
dat_mm$delta <- as.factor(dat_mm$delta)
# Since figure for "xa" is plotted to the right of that for "x", we avoid
# repeating ylab.
ytitle <- ifelse(mm == "x", "Difference in survival (%)", "")
deltas <- sort(unique(dat_mm$delta))
names(colors) <- deltas
eps0_vals <- sapply(deltas, eps0_label_fn, dat = dat_mm)
xaxis_breaks <- sort(c(0, eps0_vals[4], eps0_vals[3], eps0_vals[2], 0.25,
eps0_vals[1], 0.5))
xaxis_labs <- as.character(xaxis_breaks * 100)
if(mm == "x") {
colors <- rev(brewer.pal(4, "YlOrRd"))
newcol <- "blue"
xaxis_col <- c("black", newcol, newcol, newcol, "black", newcol, "black")
xaxis_bold <- ifelse(xaxis_col == "black", "plain" , "bold")
}
if(mm == "xa")  {
colors <- rev(brewer.pal(4, "Blues"))
newcol <- "red"
xaxis_col <- c("black", newcol, newcol, newcol, "black", newcol, "black")
xaxis_bold <- ifelse(xaxis_col == "black", "plain" , "bold")
}
p3 <- ggplot() +
geom_ribbon(data = dat_mm[dat_mm$delta == deltas[1], ],
aes(x = epsilon, ymin = lb, ymax = ub),
fill = colors[deltas[1]], alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[2]],
ymin = dat_mm$ub[dat_mm$delta == deltas[1]],
ymax = dat_mm$ub[dat_mm$delta == deltas[2]]),
fill = colors[deltas[2]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[2]],
ymin = dat_mm$lb[dat_mm$delta == deltas[2]],
ymax = dat_mm$lb[dat_mm$delta == deltas[1]]),
fill = colors[deltas[2]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[3]],
ymin = dat_mm$ub[dat_mm$delta == deltas[2]],
ymax = dat_mm$ub[dat_mm$delta == deltas[3]]),
fill = colors[deltas[3]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[3]],
ymin = dat_mm$lb[dat_mm$delta == deltas[3]],
ymax = dat_mm$lb[dat_mm$delta == deltas[2]]),
fill = colors[deltas[3]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[4]],
ymin = dat_mm$ub[dat_mm$delta == deltas[3]],
ymax = dat_mm$ub[dat_mm$delta == deltas[4]]),
fill = colors[deltas[4]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[4]],
ymin = dat_mm$lb[dat_mm$delta == deltas[4]],
ymax = dat_mm$lb[dat_mm$delta == deltas[3]]),
fill = colors[deltas[4]],
alpha = 1) +
geom_line(data = dat_mm, aes(x = epsilon, y = lb, linetype = delta),
size = 0.8, color = "black") +
geom_line(data = dat_mm, aes(x = epsilon, y = ub, linetype = delta),
size = 0.8, color = "black") +
geom_segment(data = dat_mm[dat_mm$delta == deltas[1], ], size = 0.8,
colour = newcol, alpha = 0.5,
aes(x = 0, xend = 0.50, y = 0, yend = 0)) +
scale_x_continuous(breaks = xaxis_breaks,
expand = c(0, 0), limits = c(0, 0.502),
labels = xaxis_labs) +
scale_y_continuous(breaks = c(-0.4, -0.2, dat_mm$lb[dat_mm$epsilon == 0][1],
0, 0.2),
expand = c(0,0),
limits = ylims,
labels = c(-40, -20, unconfound_label, 0, 20)) +
labs(x = "% of Confounded Units", y = ytitle, colour = "delta", fill = "") +
our_theme +
theme(axis.text.x = element_text(colour = xaxis_col, face = xaxis_bold)) +
theme(legend.position = "none")
filename <- paste0("./results/data analysis/rhc_bounds_epsilon_delta_", mm,
".pdf")
ggsave(filename = filename, p3, height = 3, width = 3)
}
View(datx)
View(datxa)
library("devtools")
library(roxygen2)
setwd("C:/Users/matte/Desktop/sensitivitypuc")
document()
# devtools::use_testthat()
Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS=TRUE)
devtools::install_github("matteobonvini/sensitivitypuc")
# devtools::install("C:/Users/matte/Desktop/sensitivitypuc")
library(sensitivitypuc)
####################################
## Run simulation as in Section 5 ##
####################################
rm(list = ls())
set.seed(1000)
library(sensitivitypuc)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("simulation_true_regression_functions.R")
truth <- readRDS("./data/truth_simulation.RData")
eps_seq <- attributes(truth)$eps_seq
eps0_seq <- attributes(truth)$eps0_seq
sl.lib <- c("SL.mean", "SL.glm", "SL.glm.interaction", "SL.gam")
nsim <- 500
n <- rev(c(500, 1000, 5000, 10000))
alpha <- 0.05
sim_fn <- function(n) {
# Function to simulate data and estimate bounds under S \ind (Y, A) | X
df <- gen_data(n)
y <- df$y
a <- df$a
x <- df[, c("x1", "x2")]
res <- get_bound(y = y, a = a, x = x, outfam = binomial(), model = "x",
ymin = 0, ymax = 1, treatfam = binomial(), eps = eps0_seq,
delta = 1, nsplits = 5, do_mult_boot = FALSE,
do_eps_zero = TRUE, alpha = alpha, sl.lib = sl.lib,
do_parallel = TRUE, ncluster = 3, do_rearrange = FALSE,
show_progress = FALSE)
bounds <- res$bounds[, , 1]
eps_zero <- res$eps_zero
# select subset of esp0_seq where to evaluate the bounds curves
idx <- which(round(eps0_seq, 10) %in% round(eps_seq, 10))
lb <- bounds[idx, "lb"]
ub <- bounds[idx, "ub"]
phibar_l <- res$phibar_lb[, idx, ]
phibar_u <- res$phibar_ub[, idx, ]
var_l <- res$var_lb[idx, 1]
var_u <- res$var_ub[idx, 1]
lb_estbar <- apply(phibar_l, 2, mean)
ub_estbar <- apply(phibar_u, 2, mean)
calpha_lb <- do_multboot(n = n, psihat = lb_estbar, sigmahat = var_l,
ifvals = phibar_l, alpha = alpha/2, B = 10000)
calpha_ub <- do_multboot(n = n, psihat = -ub_estbar, sigmahat = var_u,
ifvals = -phibar_u, alpha = alpha/2, B = 10000)
ci_lb <- get_ci(lb, sqrt(var_l/n), calpha_lb)
ci_ub <- get_ci(ub, sqrt(var_u/n), calpha_ub)
# apply rearrangement of Chernozhukov (2009)
lb <- sort(lb, decreasing = TRUE)
ub <- sort(ub)
ci_lb <- apply(ci_lb, 2, sort, decreasing = TRUE)
ci_ub <- apply(ci_ub, 2, sort)
cnames <- c("eps", "n", "lb", "ub", "eps_zero", "ci_lo", "ci_lb_hi",
"ci_ub_lo", "ci_hi", "eps_zero_lo", "eps_zero_hi")
n_row <- length(eps_seq)
n_col <- length(cnames)
out <- c(eps_seq, rep(n, n_row), lb, ub, rep(eps_zero$est, n_row),
ci_lb[, 1], ci_lb[, 2], ci_ub[, 1], ci_ub[, 2],
rep(eps_zero$ci_lo, n_row), rep(eps_zero$ci_hi, n_row))
out <- matrix(out, ncol = n_col, nrow = n_row, dimnames = list(NULL, cnames))
return(out)
}
res_cnames <- c("n", "bias_lb", "bias_ub", "bias_eps0", "rmse_lb", "rmse_ub",
"rmse_eps0", "cvg_reg", "cvg_eps0")
res <- matrix(NA, ncol = length(res_cnames), nrow = length(n),
dimnames = list(NULL, res_cnames))
for (i in 1:length(n)) {
# Simulation begins
sims <- pbreplicate(nsim, sim_fn(n[i]))
res[i, "n"] <- n[i]
res[i, "bias_lb"] <- bias(sims[, "lb", ], truth[, "lb"])
res[i, "bias_ub"] <- bias(sims[, "ub", ], truth[, "ub"])
res[i, "bias_eps0"] <- bias(sims[1, "eps_zero", ], truth[1, "eps_zero"])
res[i, "rmse_lb"] <- rmse(sims[, "lb", ], truth[, "lb"], n[i])
res[i, "rmse_ub"] <- rmse(sims[, "ub", ], truth[, "ub"], n[i])
res[i, "rmse_eps0"] <- rmse(sims[1, "eps_zero", ], truth[1, "eps_zero"], n[i])
res[i, "cvg_reg"] <- coverage(sims[, "ci_lo", ], sims[, "ci_hi", ],
truth[, "lb"], truth[, "ub"])
res[i, "cvg_eps0"] <- coverage(sims[1, "eps_zero_lo", ],
sims[1, "eps_zero_hi", ],
truth[1, "eps_zero"], truth[1, "eps_zero"])
print(res[1:i, ])
saveRDS(sims, file=paste0("./results/simulation/sims", n[i], ".RData"))
saveRDS(res, file=paste0("./results/simulation/sim_res", n[i], ".RData"))
}
saveRDS(res, file=paste0("./results/simulation/sim_res.RData"))
print(round(readRDS(paste0("./results/simulation/sim_res.RData")), 2))
