n_col <- length(cnames)
out <- c(eps_seq, rep(n, n_row), lb, ub, rep(eps_zero$est, n_row),
ci_lb_lo, ci_ub_hi, rep(eps_zero$ci_lo, n_row),
rep(eps_zero$ci_hi, n_row))
out <- matrix(out, ncol = n_col, nrow = n_row, dimnames = list(NULL, cnames))
return(out)
}
# Store the results for Table 1 in paper
res_cnames <- c("n", "bias_lb", "bias_ub", "bias_eps0", "rmse_lb", "rmse_ub",
"rmse_eps0", "cvg_reg", "cvg_eps0")
res <- matrix(NA, ncol = length(res_cnames), nrow = length(n),
dimnames = list(NULL, res_cnames))
for (i in 1:length(n)) {
# Simulation begins
sims <- pbreplicate(nsim, sim_fn(n[i], nsplits[i]))
res[i, "n"] <- n[i]
res[i, "bias_lb"] <- bias(sims[, "lb", ], truth[, "lb"])
res[i, "bias_ub"] <- bias(sims[, "ub", ], truth[, "ub"])
res[i, "bias_eps0"] <- bias(sims[1, "eps_zero", ], truth[1, "eps_zero"])
res[i, "rmse_lb"] <- rmse(sims[, "lb", ], truth[, "lb"], n[i])
res[i, "rmse_ub"] <- rmse(sims[, "ub", ], truth[, "ub"], n[i])
res[i, "rmse_eps0"] <- rmse(sims[1, "eps_zero", ], truth[1, "eps_zero"], n[i])
res[i, "cvg_reg"] <- coverage(sims[, "ci_lb_lo", ], sims[, "ci_ub_hi", ],
truth[, "lb"], truth[, "ub"])
res[i, "cvg_eps0"] <- coverage(sims[1, "eps_zero_lo", ],
sims[1, "eps_zero_hi", ],
truth[1, "eps_zero"], truth[1, "eps_zero"])
print(res[1:i, ])
saveRDS(sims, file=paste0("./results/simulation/sims", n[i], ".RData"))
saveRDS(res, file=paste0("./results/simulation/sim_res", n[i], ".RData"))
}
saveRDS(res, file=paste0("./results/simulation/sim_res.RData"))
print(round(readRDS(paste0("./results/simulation/sim_res.RData")), 2))
##########################################################
## Analyze data of Connors et al (1996) as in Section 5 ##
##########################################################
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(varhandle)
library(devtools)
Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS = TRUE) # if warnings are causing erros and they are not important one may use this
devtools::install_github("matteobonvini/sensitivitypuc")
library(sensitivitypuc)
set.seed(1000)
data_url <- "http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/rhc.csv"
dat <- read.csv(data_url, header = TRUE)
covariates <- c("age", "sex", "race", "edu", "income",
"ninsclas", "cat1", "cat2",
"resp", "card", "neuro", "gastr", "renal", "meta",
"hema", "seps", "trauma", "ortho",
"adld3p", "das2d3pc", "dnr1", "ca",  "aps1", "scoma1",
"wtkilo1", "temp1", "meanbp1", "resp1", "hrt1", "pafi1",
"paco21", "ph1", "wblc1", "hema1", "sod1", "pot1", "crea1",
"bili1", "alb1", "urin1",
"cardiohx", "chfhx", "dementhx",
"psychhx", "chrpulhx", "renalhx", "liverhx", "gibledhx",
"malighx", "immunhx", "transhx", "amihx")
x <- dat[, covariates]
miss_covs <- covariates[apply(x, 2, function(x) sum(is.na(x)) > 0)]
missdat <- as.data.frame(matrix(0, ncol = length(miss_covs), nrow = nrow(x),
dimnames = list(NULL, paste0("is_miss_", miss_covs))))
for(varname in miss_covs) {
idx <- which(is.na(x[, varname]))
if(class(x[, varname]) == "factor") {
levels(x[, varname]) <- c(levels(x[, varname]), "missing")
x[idx, varname] <- "missing"
missdat[, paste0("is_miss_", varname)] <- NULL
} else {
x[idx, varname] <- 0
missdat[idx, paste0("is_miss_", varname)] <- 1
}
}
x <- cbind(x, missdat)
# Fix factors or otherwise SuperLearner complains
newdf <- x
for(i in 1:ncol(x)) {
if(class(x[, i])=="factor") {
new <- to.dummy(x[, i], colnames(x)[i])
newdf <- newdf[, !colnames(newdf) %in% colnames(x)[i]]
newdf <- cbind(newdf, new[, -1, drop = FALSE])
}
}
x <- newdf
rm(newdf)
rm(new)
# Avoid SuperLearner conflicts due to variable names
colnames(x) <- paste("x", 1:ncol(x), sep = "")
# A = 1 means patient underwent RHC
a <- ifelse(dat$swang1 == "No RHC", 0, 1)
# Y = 1 means survival at day 30
y <- ifelse(dat$dth30 == "No", 1, 0)
# unadjusted RR (using morality as outcome)
mean(y[a == 0]) / (1 - mean(y[a == 0])) * (1 - mean(y[a == 1])) / mean(y[a == 1])
# unadjusted RD
mean(y[a == 0]) - mean(y[a == 1])
# Select values for prop of unmeasured confounding at which evaluate bounds
eps_seq <- seq(0, 0.5, 0.0001)
delta_seq <- c(0.25, 0.50, 0.75, 1)
# Select model, "x" = S \ind (Y, A) | X, "xa" = S \ind Y | (X, A)
model <- c("x", "xa")
# Select confidence level and # rademachers for multiplier bootstrap
alpha <- 0.05
B <- 10000
# Select SuperLearner Library
sl.lib <- c("SL.mean", "SL.speedlm", "SL.speedglm", "SL.gam", "SL.svm",
"SL.polymars", "SL.ranger")
nsplits <- 5
# Estimate Regression functions once for both model "x" and model "xa"
# There is a "non-list contrasts argument ignored" warning from SL gam library
# coming from model.matrix, which I think can be ignored.
system.time({
nuis_fns <- do_crossfit(y = y, a = a, x = x, ymin = 0, ymax = 1,
nsplits = nsplits, outfam = binomial(),
treatfam = binomial(), sl.lib = sl.lib,
do_parallel = TRUE, ncluster = 3)
})
rch_file_name <- paste0("./results/data analysis/nuis_fns_rhc_", nsplits,
"fold.RData")
saveRDS(nuis_fns, file = rch_file_name)
nuis_fns <- readRDS(rch_file_name)
system.time({
res_x <- get_bound(y = y, a = a, x = x, ymin = 0, ymax = 1, model = "x",
eps = eps_seq, delta = delta_seq, nuis_fns = nuis_fns,
alpha = alpha, B = B, do_mult_boot = TRUE,
do_eps_zero = TRUE, do_rearrange = TRUE)
})
system.time({
res_xa <- get_bound(y = y, a = a, x = x, ymin = 0, ymax = 1, model = "xa",
eps = eps_seq, delta = delta_seq, nuis_fns = nuis_fns,
alpha = alpha, B = B, do_mult_boot = TRUE,
do_eps_zero = TRUE, do_rearrange = TRUE)
})
saveRDS(res_x, file = paste0("./results/data analysis/res_x_", nsplits,
"fold.RData"))
saveRDS(res_xa, file = paste0("./results/data analysis/res_xa_", nsplits,
"fold.RData"))
res_x <- readRDS(paste0("./results/data analysis/res_x_", nsplits, "fold.RData"))
res_xa <- readRDS(paste0("./results/data analysis/res_xa_", nsplits, "fold.RData"))
bound_x <- res_x$bounds
bound_xa <- res_xa$bounds
eps_zero_x <- res_x$eps_zero
eps_zero_xa <- res_xa$eps_zero
round(100 * bound_x[1, , "1"], 2)
round(100 * eps_zero_x, 2)
round(100 * eps_zero_xa, 2)
# Export result in a user-friendly format
out <- NULL
for(i in 1:length(delta_seq)) {
# Loop through the values of deltas and append
dd <- delta_seq[i]
new_bound_x <- cbind(eps_seq, dd, bound_x[, , as.character(dd)],
eps_zero_x$est[i], eps_zero_x$ci_lo[i], eps_zero_x$ci_hi[i],
"x")
new_bound_xa <- cbind(eps_seq, dd, bound_xa[, , as.character(dd)],
eps_zero_xa$est[i], eps_zero_xa$ci_lo[i],
eps_zero_xa$ci_hi[i], "xa")
bound <- rbind(new_bound_x, new_bound_xa)
out <- rbind(out, bound)
}
colnames(out) <- c("epsilon", "delta", colnames(res_x$bounds[, , 1]),
"eps_zero", "eps_zero_lo", "eps_zero_hi", "model")
write.csv(out, "./results/data analysis/rhc_bounds.csv", row.names = FALSE)
# Design sensitivity
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("simulation_true_regression_functions.R")
sim_fun <- function(alpha) {
expect_y0 <- function(x1, x2, u){
return(0.5)
}
mu0x <- function(x1, x2) {
u0 <- expect_y0(x1, x2, 0) * (1-pi_xu(x1, 0)) / (1-pix(x1))
u1 <- expect_y0(x1, x2, 1) * (1-pi_xu(x1, 1)) / (1-pix(x1))
return((1-pu_x(x1)) * u0 + pu_x(x1) * u1)
}
mu0 <- adaptIntegrate(f=function(x) {
mu0x(x[1], x[2]) * densx(x[1], x[2])
}, lowerLimit=c(xlb, xlb), upperLimit=c(xub, xub), absError=1e-15)$integral
expect_y1 <- function(x1, x2, u){
return( qbeta(ptruncnorm(x2, xlb, xub), alpha, 1))
}
mu1x <- function(x1, x2) {
u0 <- expect_y1(x1, x2, 0) * pi_xu(x1, 0) / pix(x1)
u1 <- expect_y1(x1, x2, 1) * pi_xu(x1, 1) / pix(x1)
return((1-pu_x(x1)) * u0 + pu_x(x1) * u1)
}
mu1 <- adaptIntegrate(f=function(x) {
mu1x(x[1], x[2]) * densx(x[1], x[2])
}, lowerLimit=c(xlb, xlb), upperLimit=c(xub, xub), absError=1e-15)$integral
x1vals <- rtruncnorm(1e4, xlb, xub)
x2vals <- rtruncnorm(1e4, xlb, xub)
avals <- rbinom(1e4, 1, pix(x1vals))
glb_x <- gx(x1vals, x2vals) - 1
glb_xa <- gxa(x1vals, x2vals, avals) - 1
quants_lb_x <- quantile(glb_x, eps_seq)
quants_lb_xa <- quantile(glb_xa, eps_seq)
g_term_lb_x <- get_g_term(g = glb_x, quants = quants_lb_x, upper = FALSE)
g_term_lb_xa <- get_g_term(g = glb_xa, quants = quants_lb_xa, upper = FALSE)
lb_x <- mu1 - mu0 + g_term_lb_x
lb_xa <- mu1 - mu0 + g_term_lb_xa
eps0_x <- eps_seq[which.min(abs(lb_x))]
eps0_xa <- eps_seq[which.min(abs(lb_xa))]
out <- array(c(mu1 - mu0, eps0_x, eps0_xa), dim = c(1, 3))
return(out)
}
eps_seq <- seq(0, 1, 0.01)
nsim <- 100
alphas <- seq(1, 50, length.out = 100)
res <- matrix(NA, ncol = 3, nrow = length(alphas),
dimnames = list(NULL, c("tau", "eps_x", "eps_xa")))
res_sd <- matrix(NA, ncol = 3, nrow = length(alphas),
dimnames = list(NULL, c("tau", "eps_x", "eps_xa")))
for(i in 1:length(alphas)) {
sim_res <- replicate(nsim, sim_fun(alphas[i]))
res[i, ] <- apply(sim_res, c(1, 2), mean)
res_sd[i, ] <- apply(sim_res, c(1, 2), sd) / sqrt(nsim)
print(paste0("Progress = ", round(i / length(alphas) * 100, 2), " %"))
}
# Design sensitivity
rm(list = ls())
set.seed(1000)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("simulation_true_regression_functions.R")
sim_fun <- function(alpha) {
expect_y0 <- function(x1, x2, u){
return(0.5)
}
mu0x <- function(x1, x2) {
u0 <- expect_y0(x1, x2, 0) * (1-pi_xu(x1, 0)) / (1-pix(x1))
u1 <- expect_y0(x1, x2, 1) * (1-pi_xu(x1, 1)) / (1-pix(x1))
return((1-pu_x(x1)) * u0 + pu_x(x1) * u1)
}
mu0 <- adaptIntegrate(f=function(x) {
mu0x(x[1], x[2]) * densx(x[1], x[2])
}, lowerLimit=c(xlb, xlb), upperLimit=c(xub, xub), absError=1e-15)$integral
expect_y1 <- function(x1, x2, u){
return( qbeta(ptruncnorm(x2, xlb, xub), alpha, 1))
}
mu1x <- function(x1, x2) {
u0 <- expect_y1(x1, x2, 0) * pi_xu(x1, 0) / pix(x1)
u1 <- expect_y1(x1, x2, 1) * pi_xu(x1, 1) / pix(x1)
return((1-pu_x(x1)) * u0 + pu_x(x1) * u1)
}
mu1 <- adaptIntegrate(f=function(x) {
mu1x(x[1], x[2]) * densx(x[1], x[2])
}, lowerLimit=c(xlb, xlb), upperLimit=c(xub, xub), absError=1e-15)$integral
x1vals <- rtruncnorm(1e4, xlb, xub)
x2vals <- rtruncnorm(1e4, xlb, xub)
avals <- rbinom(1e4, 1, pix(x1vals))
glb_x <- gx(x1vals, x2vals) - 1
glb_xa <- gxa(x1vals, x2vals, avals) - 1
quants_lb_x <- quantile(glb_x, eps_seq)
quants_lb_xa <- quantile(glb_xa, eps_seq)
g_term_lb_x <- get_g_term(g = glb_x, quants = quants_lb_x, upper = FALSE)
g_term_lb_xa <- get_g_term(g = glb_xa, quants = quants_lb_xa, upper = FALSE)
lb_x <- mu1 - mu0 + g_term_lb_x
lb_xa <- mu1 - mu0 + g_term_lb_xa
eps0_x <- eps_seq[which.min(abs(lb_x))]
eps0_xa <- eps_seq[which.min(abs(lb_xa))]
out <- array(c(mu1 - mu0, eps0_x, eps0_xa), dim = c(1, 3))
return(out)
}
eps_seq <- seq(0, 1, 0.01)
nsim <- 100
alphas <- seq(1, 50, length.out = 100)
res <- matrix(NA, ncol = 3, nrow = length(alphas),
dimnames = list(NULL, c("tau", "eps_x", "eps_xa")))
res_sd <- matrix(NA, ncol = 3, nrow = length(alphas),
dimnames = list(NULL, c("tau", "eps_x", "eps_xa")))
for(i in 1:length(alphas)) {
sim_res <- replicate(nsim, sim_fun(alphas[i]))
res[i, ] <- apply(sim_res, c(1, 2), mean)
res_sd[i, ] <- apply(sim_res, c(1, 2), sd) / sqrt(nsim)
print(paste0("Progress = ", round(i / length(alphas) * 100, 2), " %"))
}
plot(x = alphas, y = res[, 1], type = "l", ylim = c(0, 1))
lines(x = alphas, y = res[, 2], col = "red")
lines(x = alphas, y = res[, 3], col = "blue")
saveRDS(res, file = "./results/simulation/design_sensitivity_res.RData")
library(ggplot2)
source("plot_theme.R")
label_curves <- c(bquote(tau),
bquote(paste(tilde(epsilon), " under ",
X, "-model")),
bquote(paste(tilde(epsilon), " under ",
XA, "-model")))
p <- ggplot(NULL, aes(x = alphas)) +
geom_line(aes(y = res[, "tau"], colour = "tau", linetype = "tau"),
size = 2.5) +
geom_line(aes(y = res[, "eps_x"], colour = "x", linetype = "x"),
size = 2.5) +
geom_line(aes(y = res[, "eps_xa"], colour = "xa", linetype = "xa"),
size = 2.5) +
scale_x_continuous(expand = c(0.05, 0.05),
breaks = c(1, 25, 50)) +
scale_y_continuous(expand = c(0.02, 0.02)) +
labs(x = expression(alpha), y = "", color = "", fill = "") +
scale_colour_manual(values = c("tau" = "black", "x" = "red",
"xa" = "blue"), name = "",
labels = label_curves) +
scale_linetype_manual(values=c("tau" = "solid",
"x" = "dashed",
"xa" = "dotted"),
name = "",
labels = label_curves) +
our_theme +
theme(legend.position = c(0.50, 0.2),
legend.text = element_text(colour = "black", size=50, face="bold"),
legend.direction = "vertical",
axis.title.x = element_text(size = 50),
axis.text.x = element_text(size = 50),
axis.text.y = element_text(size = 50))
p
ggsave(filename = paste0("./results/data analysis/design_sensitivity.pdf"), p,
height = 10, width = 10)
ggsave(filename = paste0("./results/simulation/design_sensitivity.pdf"), p,
height = 10, width = 10)
##################################################################
## Generate plot of the bounds for data of Connors et al (1996) ##
##################################################################
rm(list = ls())
library(RColorBrewer)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("plot_theme.R")
dat <- read.csv("./results/data analysis/rhc_bounds.csv")
datx <- dat[dat$model == "x" & dat$delta == 1, ]
datxa <- dat[dat$model == "xa" & dat$delta == 1, ]
ylims <- c(-0.45, 0.32)
models <- c("x", "xa")
colors_x <- brewer.pal(4, "YlOrRd")
colors_xa <- brewer.pal(4, "Blues")
eps0_label_fn <- function(dat, delta, round_digit = 2) {
# Return value for estimate of eps0 for a given delta, dat must be data.frame
# that results from get_bound() function.
out <- round(dat[dat$delta == delta, ]$eps_zero[1], round_digit)
return(out)
}
unconfound_val <- round(dat$lb[dat$epsilon == 0][1], 3)
unconfound_label <- as.character(unconfound_val * 100)
for(mm in models) {
## Generate plots for Figure 1, eps in [0, 0.5], delta = 1.
dat_mm <- dat[dat$model == mm & dat$delta == 1 & dat$epsilon <= 0.5, ]
eps0_label <- as.character(eps0_label_fn(dat_mm, 1, 3) * 100)
xaxis_breaks <- c(0, dat_mm$eps_zero[1], 0.10, 0.20, 0.30, 0.40, 0.50)
ytitle <- ifelse(mm == "x", "Difference in survival (%)", "")
if(mm == "x") {
colors <- colors_x
}
if(mm == "xa") {
colors <- colors_xa
}
xaxis_labs <- c(0, eps0_label, 10, 20, 30, 40, 50)
p <- ggplot() +
geom_ribbon(data = dat_mm, aes(x = epsilon, ymin = ci_lb_lo_unif,
ymax = ci_ub_hi_unif),
fill = colors[4], alpha = 1) +
geom_ribbon(data = dat_mm, aes(x = epsilon, ymin = ci_im04_lo,
ymax = ci_im04_hi), fill = colors[2],
alpha = 1) +
geom_ribbon(data = dat_mm, aes(x = epsilon, ymin = lb, ymax = ub),
fill = colors[1], alpha = 1) +
geom_line(data = dat_mm, aes(x = epsilon, y = lb), color = "black",
size = 1.1) +
geom_line(data = dat_mm, aes(x = epsilon, y = ub), color = "black",
size = 1.1) +
geom_segment(data = dat_mm[1, ], size = 0.8, colour = "black", alpha = 0.5,
aes(x = eps_zero, xend = eps_zero, y = ylims[1],  yend = 0)) +
geom_segment(data = dat_mm[1, ], size = 0.8, colour = "black", alpha = 0.5,
aes(x = 0, xend = eps_zero, y = 0, yend = 0)) +
scale_x_continuous(breaks = xaxis_breaks,
expand = c(0, 0), limits = c(0, 0.502),
labels = xaxis_labs) +
scale_y_continuous(breaks = c(-0.4, -0.2, unconfound_val, 0, 0.2),
expand = c(0,0), limits = ylims,
labels = c(-40, -20, unconfound_label, 0, 20)) +
scale_colour_manual(name = "model", values = colors) +
scale_fill_manual(name = "model", values = colors) +
labs(x = "% of Confounded Units", y = ytitle, colour = "", fill = "") +
our_theme +
theme(legend.position = "none")
ggsave(filename = paste0("./results/data analysis/rhc_bounds_epsilon_", mm,
".pdf"), p, height = 3, width = 3)
}
## Superimposing the two plots
eps0_x_label <- as.character(eps0_label_fn(datx, 1, 2) * 100)
eps0_xa_label <- as.character(eps0_label_fn(datxa, 1, 2) * 100)
p2 <- ggplot() +
geom_ribbon(data = datxa,
aes(x = epsilon, ymin = lb, ymax = ub), fill = colors_xa[2],
alpha = 1) +
geom_ribbon(data = datx,
aes(x = epsilon, ymin = lb, ymax = ub), fill = colors_x[2],
alpha = 1) +
geom_line(data = datx, aes(x = epsilon, y = lb), color = "black",
size = 1.1) +
geom_line(data = datxa, aes(x = epsilon, y = lb), color = "black",
linetype = "dashed", size = 1.1) +
geom_line(data = datx, aes(x = epsilon, y = ub), color = "black",
size = 1.1) +
geom_line(data = datxa, aes(x = epsilon, y = ub), color = "black",
linetype = "dashed", size = 1.1) +
geom_segment(data = datx[1, ],
aes(x = eps_zero, xend = eps_zero, y = ylims[1], yend = 0),
size = 0.8, colour = "red", alpha = 0.75) +
geom_segment(data = datxa[1, ],
aes(x = eps_zero, xend = eps_zero, y = ylims[1], yend = 0),
size = 0.8, colour = "blue", alpha = 0.75) +
geom_segment(data = datx[1, ],
aes(x = 0, xend = eps_zero, y = 0, yend = 0),
size = 0.8, colour = "black", alpha = 0.5) +
scale_x_continuous(breaks = c(0, datxa$eps_zero[1],
datx$eps_zero[1], 0.2,0.5),
expand = c(0, 0), limits = c(0, 0.5),
labels = c(0, eps0_xa_label, eps0_x_label, 20, 50)) +
scale_y_continuous(breaks = c(-0.2, -0.1, unconfound_val, 0, 0.1),
expand = c(0,0), limits = ylims,
labels = c("-20", "-10", unconfound_label, "0", "10")) +
scale_colour_manual(name = "model", values = colors) +
scale_fill_manual(name = "model", values = colors) +
labs(x = "% of Confounded Units", y = "Difference in survival (%)",
colour = "", fill = "") +
our_theme +
theme(legend.position = "none")
ggsave(filename = "./results/data analysis/rhc_bounds_epsilon.pdf", p2,
height = 3, width = 3)
## Plot eps_delta
dat <- read.csv("./results/data analysis/rhc_bounds.csv")
models <- c("x", "xa")
ylims <- c(-0.45, 0.32)
for(mm in models) {
## Generate plots for appendix figure, eps in [0, 0.5] with different deltas.
dat_mm <- dat[dat$model == mm & dat$epsilon <= 0.5, ]
dat_mm$delta <- as.factor(dat_mm$delta)
# Since figure for "xa" is plotted to the right of that for "x", we avoid
# repeating ylab.
ytitle <- ifelse(mm == "x", "Difference in survival (%)", "")
deltas <- sort(unique(dat_mm$delta))
names(colors) <- deltas
eps0_vals <- sapply(deltas, eps0_label_fn, dat = dat_mm, round_digit = 2)
xaxis_breaks <- sort(c(0, eps0_vals[4], eps0_vals[3], eps0_vals[2],
eps0_vals[1], 0.5))
xaxis_labs <- as.character(xaxis_breaks * 100)
if(mm == "x") {
colors <- rev(brewer.pal(4, "YlOrRd"))
newcol <- "blue"
xaxis_col <- c("black", newcol, newcol, newcol, newcol, "black")
xaxis_bold <- ifelse(xaxis_col == "black", "plain" , "bold")
}
if(mm == "xa")  {
colors <- rev(brewer.pal(4, "Blues"))
newcol <- "red"
xaxis_col <- c("black", newcol, newcol, newcol, newcol, "black")
xaxis_bold <- ifelse(xaxis_col == "black", "plain" , "bold")
}
p3 <- ggplot() +
geom_ribbon(data = dat_mm[dat_mm$delta == deltas[1], ],
aes(x = epsilon, ymin = lb, ymax = ub),
fill = colors[deltas[1]], alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[2]],
ymin = dat_mm$ub[dat_mm$delta == deltas[1]],
ymax = dat_mm$ub[dat_mm$delta == deltas[2]]),
fill = colors[deltas[2]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[2]],
ymin = dat_mm$lb[dat_mm$delta == deltas[2]],
ymax = dat_mm$lb[dat_mm$delta == deltas[1]]),
fill = colors[deltas[2]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[3]],
ymin = dat_mm$ub[dat_mm$delta == deltas[2]],
ymax = dat_mm$ub[dat_mm$delta == deltas[3]]),
fill = colors[deltas[3]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[3]],
ymin = dat_mm$lb[dat_mm$delta == deltas[3]],
ymax = dat_mm$lb[dat_mm$delta == deltas[2]]),
fill = colors[deltas[3]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[4]],
ymin = dat_mm$ub[dat_mm$delta == deltas[3]],
ymax = dat_mm$ub[dat_mm$delta == deltas[4]]),
fill = colors[deltas[4]],
alpha = 1) +
geom_ribbon(aes(x = dat_mm$epsilon[dat_mm$delta == deltas[4]],
ymin = dat_mm$lb[dat_mm$delta == deltas[4]],
ymax = dat_mm$lb[dat_mm$delta == deltas[3]]),
fill = colors[deltas[4]],
alpha = 1) +
geom_line(data = dat_mm, aes(x = epsilon, y = lb, linetype = delta),
size = 0.8, color = "black") +
geom_line(data = dat_mm, aes(x = epsilon, y = ub, linetype = delta),
size = 0.8, color = "black") +
geom_segment(data = dat_mm[dat_mm$delta == deltas[1], ], size = 0.8,
colour = newcol, alpha = 0.5,
aes(x = 0, xend = 0.50, y = 0, yend = 0)) +
scale_x_continuous(breaks = xaxis_breaks,
expand = c(0, 0), limits = c(0, 0.502),
labels = xaxis_labs) +
scale_y_continuous(breaks = c(-0.4, -0.2, dat_mm$lb[dat_mm$epsilon == 0][1],
0, 0.2),
expand = c(0,0),
limits = ylims,
labels = c(-40, -20, unconfound_label, 0, 20)) +
labs(x = "% of Confounded Units", y = ytitle, colour = "delta", fill = "") +
our_theme +
theme(axis.text.x = element_text(colour = xaxis_col, face = xaxis_bold)) +
theme(legend.position = "none")
filename <- paste0("./results/data analysis/rhc_bounds_epsilon_delta_", mm,
".pdf")
ggsave(filename = filename, p3, height = 4, width = 4)
}
print(round(readRDS(paste0("./results/simulation/sim_res.RData")), 2))
